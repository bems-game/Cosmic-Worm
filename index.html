<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arena Cacing Kosmik (Final Fix)</title>
    <!-- Memuat Tone.js untuk musik dan suara -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        body {
            margin: 0;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
        }
        canvas {
            display: block;
            background-color: #0d1117;
            cursor: none; /* Sembunyikan kursor asli */
        }
        .ui-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            background-color: rgba(0,0,0,0.8);
            color: white;
            text-align: center;
            z-index: 10;
        }
        h1 { font-size: 3rem; text-shadow: 0 0 10px #00ffff; }
        p { font-size: 1.2rem; }
        button {
            padding: 1rem 2rem;
            font-size: 1.5rem;
            background-color: #00aaff;
            color: white;
            border: 2px solid #00ffff;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }
        button:hover { background-color: #00ffff; color: #000; }
        #score-board {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 1.5em;
            text-shadow: 0 0 5px #fff;
            display: none; /* Awalnya disembunyikan */
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="score-board">Panjang: <span id="score">0</span></div>
    <div id="start-screen" class="ui-overlay">
        <h1>Arena Cacing Kosmik</h1>
        <p>Gerakkan mouse untuk mengontrol cacing. Tahan klik untuk nge-boost!</p>
        <p>Jangan menabrak cacing lain atau dinding!</p>
        <button id="start-button">Mulai</button>
    </div>
    <div id="game-over-screen" class="ui-overlay" style="display: none;">
        <h1>GAME OVER</h1>
        <p>Panjang Akhir: <span id="final-score">0</span></p>
        <button id="restart-button">Coba Lagi</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // --- UI Elements ---
        const scoreEl = document.getElementById('score');
        const scoreBoard = document.getElementById('score-board');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreEl = document.getElementById('final-score');
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');

        // --- Game State ---
        let player, foods, aiWorms, camera, sfx, music;
        let gameState = 'start';
        const worldSize = 2000;
        let mousePos = { x: canvas.width / 2, y: canvas.height / 2 };
        let isBoosting = false;

        class Worm {
            constructor(isPlayer = false) {
                this.isPlayer = isPlayer;
                this.id = Math.random();
                this.x = Math.random() * worldSize;
                this.y = Math.random() * worldSize;
                this.radius = 10;
                this.baseSpeed = isPlayer ? 3.5 : 2; 
                this.speed = this.baseSpeed;
                this.color = `hsl(${Math.random() * 360}, 100%, 50%)`;
                this.segments = [];
                for (let i = 0; i < 10; i++) {
                    this.segments.push({ x: this.x, y: this.y });
                }
                this.target = { x: this.x, y: this.y };
            }

            update() {
                if (this.isPlayer) {
                    if (isBoosting && this.segments.length > 10) {
                        this.speed = this.baseSpeed * 2;
                        if (Math.random() > 0.8) {
                            const tail = this.segments[this.segments.length - 1];
                            const droppedFood = new Food(tail.x, tail.y, true);
                            droppedFood.color = this.color;
                            foods.push(droppedFood);
                            this.segments.pop();
                        }
                    } else {
                        this.speed = this.baseSpeed;
                    }
                    const worldMouseX = mousePos.x + camera.x;
                    const worldMouseY = mousePos.y + camera.y;
                    this.target = { x: worldMouseX, y: worldMouseY };
                } else {
                    if (Math.random() > 0.99) {
                        this.target = { x: Math.random() * worldSize, y: Math.random() * worldSize };
                    }
                }

                const dx = this.target.x - this.segments[0].x;
                const dy = this.target.y - this.segments[0].y;
                const angle = Math.atan2(dy, dx);
                
                const vx = Math.cos(angle) * this.speed;
                const vy = Math.sin(angle) * this.speed;

                this.segments[0].x += vx;
                this.segments[0].y += vy;

                for (let i = 1; i < this.segments.length; i++) {
                    const dx_s = this.segments[i-1].x - this.segments[i].x;
                    const dy_s = this.segments[i-1].y - this.segments[i].y;
                    this.segments[i].x += dx_s * 0.8;
                    this.segments[i].y += dy_s * 0.8;
                }
            }

            draw() {
                for (let i = this.segments.length - 1; i >= 0; i--) {
                    ctx.beginPath();
                    ctx.arc(this.segments[i].x, this.segments[i].y, this.radius * (1 - i / (this.segments.length * 1.5)), 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                }
                const head = this.segments[0];
                const angle = Math.atan2(this.target.y - head.y, this.target.x - head.x);
                const eyeX = head.x + Math.cos(angle) * this.radius / 2;
                const eyeY = head.y + Math.sin(angle) * this.radius / 2;
                ctx.beginPath();
                ctx.arc(eyeX, eyeY, this.radius / 3, 0, Math.PI * 2);
                ctx.fillStyle = 'white';
                ctx.fill();
                ctx.beginPath();
                ctx.arc(eyeX, eyeY, this.radius / 6, 0, Math.PI * 2);
                ctx.fillStyle = 'black';
                ctx.fill();
            }
            
            grow() {
                for(let i=0; i<5; i++) {
                    this.segments.push({ ...this.segments[this.segments.length - 1] });
                }
            }
        }

        class Food {
            constructor(x, y, isDeathPellet = false) {
                this.x = x || Math.random() * worldSize;
                this.y = y || Math.random() * worldSize;
                this.radius = isDeathPellet ? 7 : 5;
                this.isDeathPellet = isDeathPellet;
                this.color = `hsl(${Math.random() * 360}, 100%, 75%)`;
            }
            draw() {
                if (!this.isDeathPellet) {
                    ctx.shadowColor = this.color;
                    ctx.shadowBlur = 15;
                }
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
        }

        // FIX: Renamed init() to resetGame() for clarity
        function resetGame() {
            player = new Worm(true);
            foods = [];
            aiWorms = [];
            camera = { x: player.segments[0].x - canvas.width / 2, y: player.segments[0].y - canvas.height / 2 };
            
            for(let i=0; i<200; i++) foods.push(new Food());
            for(let i=0; i<15; i++) aiWorms.push(new Worm());
        }

        function update() {
            if (gameState !== 'playing') return;

            const allWorms = [player, ...aiWorms];
            
            allWorms.forEach(w => w.update());

            allWorms.forEach(worm => {
                for (let i = foods.length - 1; i >= 0; i--) {
                    const food = foods[i];
                    const dx = worm.segments[0].x - food.x;
                    const dy = worm.segments[0].y - food.y;
                    if (dx*dx + dy*dy < (worm.radius + food.radius) * (worm.radius + food.radius)) {
                        if (worm.isPlayer && sfx) sfx.eat.triggerAttackRelease("C5", "8n");
                        foods.splice(i, 1);
                        if (!food.isDeathPellet) {
                            foods.push(new Food());
                        }
                        worm.grow();
                        break; 
                    }
                }
            });

            const wormsToKill = new Set();
            for (const attacker of allWorms) {
                const head = attacker.segments[0];
                if (head.x < 0 || head.x > worldSize || head.y < 0 || head.y > worldSize) {
                    wormsToKill.add(attacker);
                    continue;
                }
                for (const target of allWorms) {
                    if (attacker.id === target.id) continue;
                    for (let i = 1; i < target.segments.length; i++) {
                        const segment = target.segments[i];
                        const dx = head.x - segment.x;
                        const dy = head.y - segment.y;
                        if (dx*dx + dy*dy < attacker.radius * attacker.radius) {
                            wormsToKill.add(attacker);
                            break;
                        }
                    }
                    if (wormsToKill.has(attacker)) break;
                }
            }

            wormsToKill.forEach(worm => killWorm(worm));
            
            if (gameState === 'playing') {
                scoreEl.textContent = player.segments.length;
            }
        }
        
        function killWorm(worm) {
            if (worm.isPlayer) {
                if (gameState === 'playing') endGame();
            } else {
                const index = aiWorms.findIndex(w => w.id === worm.id);
                if (index > -1) {
                    const foodCount = Math.min(worm.segments.length, 50);
                    for (let i = 0; i < foodCount; i++) {
                        const seg = worm.segments[i];
                        const food = new Food(seg.x, seg.y, true);
                        food.color = worm.color;
                        foods.push(food);
                    }
                    aiWorms.splice(index, 1);
                    setTimeout(() => aiWorms.push(new Worm()), 2000);
                }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if(player) {
                camera.x += (player.segments[0].x - canvas.width / 2 - camera.x) * 0.1;
                camera.y += (player.segments[0].y - canvas.height / 2 - camera.y) * 0.1;
            }

            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 1;
            for (let x = -camera.x % 50; x < canvas.width; x += 50) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke(); }
            for (let y = -camera.y % 50; y < canvas.height; y += 50) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke(); }

            ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.lineWidth = 20;
            ctx.strokeRect(0, 0, worldSize, worldSize);
            ctx.lineWidth = 1;

            foods.forEach(f => f.draw());
            ctx.shadowBlur = 0;
            aiWorms.forEach(w => w.draw());
            if(player) player.draw();

            ctx.restore();
        }

        function gameLoop() {
            if (gameState === 'playing') {
                update();
            }
            // FIX: Always draw the game world, even when paused or on menus
            draw();
            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            const startPlaying = () => {
                resetGame(); // Use the new reset function
                if (!sfx) initAudio();
                Tone.Transport.start();
                gameState = 'playing';
                startScreen.style.display = 'none';
                gameOverScreen.style.display = 'none';
                scoreBoard.style.display = 'block';
            };

            if (Tone.context.state !== 'running') {
                Tone.start().then(startPlaying);
            } else {
                startPlaying();
            }
        }

        function endGame() {
            if (gameState !== 'playing') return;
            if (sfx && sfx.gameOver) sfx.gameOver.triggerAttackRelease("C3", "2n");
            if (Tone.Transport.state === 'started') Tone.Transport.stop();
            gameState = 'gameOver';
            finalScoreEl.textContent = player.segments.length;
            gameOverScreen.style.display = 'flex';
            scoreBoard.style.display = 'none';
        }
        
        function initAudio() {
            if (sfx) return;
            sfx = {
                eat: new Tone.Synth({oscillator: {type: 'triangle'}, envelope: {attack: 0.005, decay: 0.1, sustain: 0.1, release: 0.2}}).toDestination(),
                gameOver: new Tone.Synth().toDestination()
            };
            music = new Tone.FMSynth({
                harmonicity: 1.5, modulationIndex: 1.2,
                envelope: { attack: 2, decay: 1, sustain: 0.5, release: 4 },
            }).toDestination();
            music.volume.value = -20;
            const musicLoop = new Tone.Loop(time => {
                music.triggerAttackRelease("C2", "1n", time);
            }, "1n").start(0);
        }

        // Event Listeners
        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', startGame);
        window.addEventListener('mousemove', (e) => {
            mousePos = { x: e.clientX, y: e.clientY };
        });
        window.addEventListener('mousedown', () => { if(gameState === 'playing') isBoosting = true; });
        window.addEventListener('mouseup', () => { if(gameState === 'playing') isBoosting = false; });
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
        
        // FIX: Initialize the game state once before the loop starts
        resetGame();
        gameLoop();

    </script>
</body>
</html>
