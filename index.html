const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // --- UI Elements ---
        const scoreEl = document.getElementById('score');
        const scoreBoard = document.getElementById('score-board');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreEl = document.getElementById('final-score');
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');
        const instructionText = document.getElementById('instruction-text');

        // --- Game State ---
        let player, foods, aiWorms, camera, sfx, music;
        let gameState = 'start';
        const worldSize = 3000;
        let isBoosting = false;

        const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        if (isTouchDevice) {
            instructionText.innerHTML = "<b>Sentuh dan geser</b> untuk mengarahkan cacing.<br>Cacing akan nge-boost otomatis saat disentuh.";
        } else {
             instructionText.innerHTML = "<b>Gerakkan mouse</b> untuk mengarahkan cacing.<br><b>Tahan klik</b> untuk nge-boost!";
        }

        // --- Class Definitions ---
        class Worm {
            constructor(isPlayer = false) {
                this.isPlayer = isPlayer;
                this.id = Math.random();
                this.radius = 10;
                this.baseSpeed = isPlayer ? 3.2 : 2.0;
                this.speed = this.baseSpeed;
                this.color = `hsl(${Math.random() * 360}, 100%, 60%)`;
                this.angle = Math.random() * Math.PI * 2;
                this.targetFood = null; // For AI

                this.segments = [];
                const startX = Math.random() * (worldSize - 200) + 100;
                const startY = Math.random() * (worldSize - 200) + 100;
                for (let i = 0; i < 15; i++) {
                    this.segments.push({ x: startX, y: startY });
                }
            }

            update() {
                // Boost logic
                if (this.isPlayer && isBoosting && this.segments.length > 15) {
                    this.speed = this.baseSpeed * 2;
                    if (Math.random() > 0.85) {
                        const tail = this.segments.pop();
                        const droppedFood = new Food(tail.x, tail.y, true);
                        droppedFood.color = this.color;
                        foods.push(droppedFood);
                    }
                } else {
                    this.speed = this.baseSpeed;
                }

                // AI logic: Find nearest food
                if (!this.isPlayer) {
                    if (!this.targetFood || this.targetFood.eaten || Math.random() < 0.05) {
                        let closestFood = null;
                        let minDistanceSq = Infinity;
                        foods.forEach(food => {
                            if (food.eaten) return;
                            const dx = food.x - this.segments[0].x;
                            const dy = food.y - this.segments[0].y;
                            const distSq = dx * dx + dy * dy;
                            if (distSq < minDistanceSq) {
                                minDistanceSq = distSq;
                                closestFood = food;
                            }
                        });
                        this.targetFood = closestFood;
                    }
                    if (this.targetFood) {
                        const dx = this.targetFood.x - this.segments[0].x;
                        const dy = this.targetFood.y - this.segments[0].y;
                        const targetAngle = Math.atan2(dy, dx);
                        let angleDiff = targetAngle - this.angle;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        this.angle += angleDiff * 0.08; // AI turn speed
                    }
                }

                // Movement: Always forward based on angle
                const vx = Math.cos(this.angle) * this.speed;
                const vy = Math.sin(this.angle) * this.speed;
                this.segments[0].x += vx;
                this.segments[0].y += vy;

                // Body segment follow logic
                for (let i = 1; i < this.segments.length; i++) {
                    const leader = this.segments[i - 1];
                    const follower = this.segments[i];
                    const dx_s = leader.x - follower.x;
                    const dy_s = leader.y - follower.y;
                    const dist_s = Math.sqrt(dx_s * dx_s + dy_s * dy_s);
                    const lag = this.radius * 0.6; // Distance between segments
                    if (dist_s > lag) {
                        follower.x = leader.x - (dx_s / dist_s) * lag;
                        follower.y = leader.y - (dy_s / dist_s) * lag;
                    }
                }
            }

            draw() {
                for (let i = this.segments.length - 1; i >= 0; i--) {
                    ctx.beginPath();
                    const scale = 1 - i / (this.segments.length * 1.5);
                    ctx.arc(this.segments[i].x, this.segments[i].y, this.radius * scale, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                }
                // Eyes
                const head = this.segments[0];
                const eyeRadius = this.radius / 3;
                const eyeOffsetX = Math.cos(this.angle + Math.PI / 4) * this.radius * 0.6;
                const eyeOffsetY = Math.sin(this.angle + Math.PI / 4) * this.radius * 0.6;
                const eye2OffsetX = Math.cos(this.angle - Math.PI / 4) * this.radius * 0.6;
                const eye2OffsetY = Math.sin(this.angle - Math.PI / 4) * this.radius * 0.6;

                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(head.x + eyeOffsetX, head.y + eyeOffsetY, eyeRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(head.x + eye2OffsetX, head.y + eye2OffsetY, eyeRadius, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(head.x + eyeOffsetX, head.y + eyeOffsetY, eyeRadius / 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(head.x + eye2OffsetX, head.y + eye2OffsetY, eyeRadius / 2, 0, Math.PI * 2);
                ctx.fill();
            }

            grow() {
                for (let i = 0; i < 3; i++) {
                    this.segments.push({ ...this.segments[this.segments.length - 1] });
                }
            }
        }

        class Food {
            constructor(x, y, isDeathPellet = false) {
                this.x = x || Math.random() * worldSize;
                this.y = y || Math.random() * worldSize;
                this.radius = isDeathPellet ? 7 : 5;
                this.isDeathPellet = isDeathPellet;
                this.color = `hsl(${Math.random() * 360}, 100%, 75%)`;
                this.eaten = false;
            }
            draw() {
                if (!this.isDeathPellet) {
                    ctx.shadowColor = this.color;
                    ctx.shadowBlur = 15;
                }
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.shadowBlur = 0; // Reset shadow
            }
        }

        // --- Game Functions ---
        function resetGame() {
            player = new Worm(true);
            camera = { x: player.segments[0].x - canvas.width / 2, y: player.segments[0].y - canvas.height / 2 };
            foods = [];
            for (let i = 0; i < 300; i++) foods.push(new Food());
            aiWorms = [];
            for (let i = 0; i < 20; i++) aiWorms.push(new Worm());
        }

        function update() {
            if (gameState !== 'playing') return;

            const allWorms = [player, ...aiWorms];
            allWorms.forEach(w => w.update());

            // Food collision
            allWorms.forEach(worm => {
                for (let i = foods.length - 1; i >= 0; i--) {
                    const food = foods[i];
                    if (food.eaten) continue;
                    const dx = worm.segments[0].x - food.x;
                    const dy = worm.segments[0].y - food.y;
                    if (dx * dx + dy * dy < (worm.radius + food.radius) ** 2) {
                        if (worm.isPlayer && sfx) sfx.eat.triggerAttackRelease("C5", "8n");
                        food.eaten = true;
                        foods.splice(i, 1);
                        if (!food.isDeathPellet) foods.push(new Food());
                        worm.grow();
                        break;
                    }
                }
            });

            // Worm collision
            const wormsToKill = new Set();
            for (const attacker of allWorms) {
                const head = attacker.segments[0];
                if (head.x < 0 || head.x > worldSize || head.y < 0 || head.y > worldSize) {
                    wormsToKill.add(attacker);
                    continue;
                }
                for (const target of allWorms) {
                    if (attacker.id === target.id) continue;
                    for (let i = 1; i < target.segments.length; i++) {
                        const segment = target.segments[i];
                        const dx = head.x - segment.x;
                        const dy = head.y - segment.y;
                        if (dx * dx + dy * dy < attacker.radius ** 2) {
                            wormsToKill.add(attacker);
                            break;
                        }
                    }
                    if (wormsToKill.has(attacker)) break;
                }
            }
            wormsToKill.forEach(worm => killWorm(worm));

            if (gameState === 'playing') {
                scoreEl.textContent = player.segments.length;
            }
        }

        function killWorm(worm) {
            if (worm.isPlayer) {
                if (gameState === 'playing') endGame();
                return;
            }

            const index = aiWorms.findIndex(w => w.id === worm.id);
            if (index > -1) {
                const foodCount = Math.min(worm.segments.length, 40);
                for (let i = 0; i < foodCount; i++) {
                    const seg = worm.segments[Math.floor(Math.random() * worm.segments.length)];
                    const food = new Food(seg.x, seg.y, true);
                    food.color = worm.color;
                    foods.push(food);
                }
                aiWorms.splice(index, 1);
                setTimeout(() => aiWorms.push(new Worm()), 3000);
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (player && camera) {
                camera.x += (player.segments[0].x - canvas.width / 2 - camera.x) * 0.1;
                camera.y += (player.segments[0].y - canvas.height / 2 - camera.y) * 0.1;
            }

            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            // Draw grid, bounds, food, worms
            foods.forEach(f => f.draw());
            aiWorms.forEach(w => w.draw());
            if (player) player.draw();

            ctx.restore();
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            const startPlaying = () => {
                resetGame();
                if (!sfx) initAudio();
                if (Tone.Transport.state !== 'started') Tone.Transport.start();
                gameState = 'playing';
                startScreen.style.display = 'none';
                gameOverScreen.style.display = 'none';
                scoreBoard.style.display = 'block';
            };
            if (Tone.context.state !== 'running') {
                Tone.start().then(startPlaying);
            } else {
                startPlaying();
            }
        }

        function endGame() {
            if (gameState !== 'playing') return;
            if (sfx && sfx.gameOver) sfx.gameOver.triggerAttackRelease("C3", "2n");
            if (Tone.Transport.state === 'started') Tone.Transport.stop();
            gameState = 'gameOver';
            finalScoreEl.textContent = player.segments.length;
            gameOverScreen.style.display = 'flex';
            scoreBoard.style.display = 'none';
        }

        function initAudio() {
            if (sfx) return;
            sfx = {
                eat: new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.1, release: 0.2 } }).toDestination(),
                gameOver: new Tone.Synth().toDestination()
            };
        }

        // --- Event Listeners ---
        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', startGame);

        function updatePlayerAngle(clientX, clientY) {
            if (!player) return;
            const canvasCenterX = canvas.width / 2;
            const canvasCenterY = canvas.height / 2;
            player.angle = Math.atan2(clientY - canvasCenterY, clientX - canvasCenterX);
        }

        // Desktop Controls
        window.addEventListener('mousemove', (e) => {
            if (isTouchDevice || gameState !== 'playing') return;
            updatePlayerAngle(e.clientX, e.clientY);
        });
        window.addEventListener('mousedown', () => { if (gameState === 'playing' && !isTouchDevice) isBoosting = true; });
        window.addEventListener('mouseup', () => { if (gameState === 'playing' && !isTouchDevice) isBoosting = false; });

        // Mobile Controls
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameState === 'playing') {
                isBoosting = true;
                updatePlayerAngle(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: false });
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (gameState === 'playing') {
                updatePlayerAngle(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: false });
        canvas.addEventListener('touchend', () => {
            if (gameState === 'playing') isBoosting = false;
        });

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // --- Initial Call ---
        gameLoop();
