<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Arena Cacing Kosmik (Mobile Fixed)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        body {
            margin: 0;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden; /* Mencegah scrolling di mobile */
            font-family: 'Arial', sans-serif;
            -webkit-user-select: none; /* Safari */
            -ms-user-select: none; /* IE 10+ */
            user-select: none; /* Standard syntax */
        }
        canvas {
            display: block;
            background-color: #0d1117;
            cursor: none; /* Sembunyikan kursor asli */
        }
        .ui-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            background-color: rgba(0,0,0,0.8);
            color: white;
            text-align: center;
            z-index: 10;
            padding: 20px;
            box-sizing: border-box;
        }
        h1 { font-size: 2.5rem; text-shadow: 0 0 10px #00ffff; }
        p { font-size: 1.1rem; line-height: 1.5; }
        button {
            padding: 1rem 2rem;
            font-size: 1.5rem;
            background-color: #00aaff;
            color: white;
            border: 2px solid #00ffff;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }
        button:hover, button:active { background-color: #00ffff; color: #000; }
        #score-board {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 1.5em;
            text-shadow: 0 0 5px #fff;
            display: none; /* Awalnya disembunyikan */
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="score-board">Panjang: <span id="score">0</span></div>
    <div id="start-screen" class="ui-overlay">
        <h1>Arena Cacing Kosmik</h1>
        <p id="instruction-text">Gerakkan mouse untuk mengontrol cacing.<br>Tahan klik untuk nge-boost!</p>
        <p>Jangan menabrak cacing lain atau dinding!</p>
        <button id="start-button">Mulai</button>
    </div>
    <div id="game-over-screen" class="ui-overlay" style="display: none;">
        <h1>GAME OVER</h1>
        <p>Panjang Akhir: <span id="final-score">0</span></p>
        <button id="restart-button">Coba Lagi</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // --- UI Elements ---
        const scoreEl = document.getElementById('score');
        const scoreBoard = document.getElementById('score-board');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreEl = document.getElementById('final-score');
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');
        const instructionText = document.getElementById('instruction-text'); // [FIX] Ambil elemen instruksi

        // --- Game State ---
        let player, foods, aiWorms, camera, sfx, music;
        let gameState = 'start';
        const worldSize = 2000;
        let mousePos = { x: canvas.width / 2, y: canvas.height / 2 };
        let isBoosting = false;
        
        // --- Mobile Joystick State ---
        let joystickActive = false;
        let joystickCenter = { x: 0, y: 0 };
        let joystickVector = { x: 0, y: 0 };
        
        // [FIX] Deteksi perangkat sentuh untuk mengubah instruksi
        const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        if (isTouchDevice) {
            instructionText.innerHTML = "<b>Sentuh dan tahan</b> di layar untuk bergerak dan nge-boost.<br>Arahkan cacing dengan menggeser jarimu.";
        }


        class Worm {
            constructor(isPlayer = false) {
                this.isPlayer = isPlayer;
                this.id = Math.random();
                this.x = Math.random() * worldSize;
                this.y = Math.random() * worldSize;
                this.radius = 10;
                this.baseSpeed = isPlayer ? 3.5 : 2; 
                this.speed = this.baseSpeed;
                this.color = `hsl(${Math.random() * 360}, 100%, 50%)`;
                this.segments = [];
                for (let i = 0; i < 10; i++) {
                    this.segments.push({ x: this.x, y: this.y });
                }
                this.target = { x: this.x, y: this.y };
            }

            update() {
                if (this.isPlayer) {
                    if (isBoosting && this.segments.length > 10) {
                        this.speed = this.baseSpeed * 2;
                        if (Math.random() > 0.8) {
                            const tail = this.segments[this.segments.length - 1];
                            const droppedFood = new Food(tail.x, tail.y, true);
                            droppedFood.color = this.color;
                            foods.push(droppedFood);
                            this.segments.pop();
                        }
                    } else {
                        this.speed = this.baseSpeed;
                    }

                    // Logika kontrol cacing pemain
                    if (joystickActive) {
                        // Mobile touch logic
                        const dist = Math.sqrt(joystickVector.x**2 + joystickVector.y**2);
                        if (dist > 0) {
                            const angle = Math.atan2(joystickVector.y, joystickVector.x);
                            this.target.x = this.segments[0].x + Math.cos(angle) * 100;
                            this.target.y = this.segments[0].y + Math.sin(angle) * 100;
                        }
                    } else {
                        // Desktop mouse logic
                        const worldMouseX = mousePos.x + camera.x;
                        const worldMouseY = mousePos.y + camera.y;
                        this.target = { x: worldMouseX, y: worldMouseY };
                    }
                } else { // Logika AI
                    if (Math.random() > 0.99) {
                        this.target = { x: Math.random() * worldSize, y: Math.random() * worldSize };
                    }
                }

                const dx = this.target.x - this.segments[0].x;
                const dy = this.target.y - this.segments[0].y;
                const angle = Math.atan2(dy, dx);
                
                const vx = Math.cos(angle) * this.speed;
                const vy = Math.sin(angle) * this.speed;

                this.segments[0].x += vx;
                this.segments[0].y += vy;

                for (let i = 1; i < this.segments.length; i++) {
                    const dx_s = this.segments[i-1].x - this.segments[i].x;
                    const dy_s = this.segments[i-1].y - this.segments[i].y;
                    this.segments[i].x += dx_s * 0.8;
                    this.segments[i].y += dy_s * 0.8;
                }
            }

            draw() {
                for (let i = this.segments.length - 1; i >= 0; i--) {
                    ctx.beginPath();
                    ctx.arc(this.segments[i].x, this.segments[i].y, this.radius * (1 - i / (this.segments.length * 1.5)), 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                }
                const head = this.segments[0];
                const angle = Math.atan2(this.target.y - head.y, this.target.x - head.x);
                const eyeX = head.x + Math.cos(angle) * this.radius / 2;
                const eyeY = head.y + Math.sin(angle) * this.radius / 2;
                ctx.beginPath();
                ctx.arc(eyeX, eyeY, this.radius / 3, 0, Math.PI * 2);
                ctx.fillStyle = 'white';
                ctx.fill();
                ctx.beginPath();
                ctx.arc(eyeX, eyeY, this.radius / 6, 0, Math.PI * 2);
                ctx.fillStyle = 'black';
                ctx.fill();
            }
            
            grow() {
                for(let i=0; i<5; i++) {
                    this.segments.push({ ...this.segments[this.segments.length - 1] });
                }
            }
        }

        class Food {
            constructor(x, y, isDeathPellet = false) {
                this.x = x || Math.random() * worldSize;
                this.y = y || Math.random() * worldSize;
                this.radius = isDeathPellet ? 7 : 5;
                this.isDeathPellet = isDeathPellet;
                this.color = `hsl(${Math.random() * 360}, 100%, 75%)`;
            }
            draw() {
                if (!this.isDeathPellet) {
                    ctx.shadowColor = this.color;
                    ctx.shadowBlur = 15;
                }
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
        }

        function resetGame() {
            player = new Worm(true);
            foods = [];
            aiWorms = [];
            camera = { x: player.segments[0].x - canvas.width / 2, y: player.segments[0].y - canvas.height / 2 };
            
            for(let i=0; i<200; i++) foods.push(new Food());
            for(let i=0; i<15; i++) aiWorms.push(new Worm());
        }

        function update() {
            if (gameState !== 'playing') return;
            const allWorms = [player, ...aiWorms];
            allWorms.forEach(w => w.update());

            allWorms.forEach(worm => {
                for (let i = foods.length - 1; i >= 0; i--) {
                    const food = foods[i];
                    const dx = worm.segments[0].x - food.x;
                    const dy = worm.segments[0].y - food.y;
                    if (dx*dx + dy*dy < (worm.radius + food.radius) * (worm.radius + food.radius)) {
                        if (worm.isPlayer && sfx) sfx.eat.triggerAttackRelease("C5", "8n");
                        foods.splice(i, 1);
                        if (!food.isDeathPellet) {
                            foods.push(new Food());
                        }
                        worm.grow();
                        break; 
                    }
                }
            });

            const wormsToKill = new Set();
            for (const attacker of allWorms) {
                const head = attacker.segments[0];
                if (head.x < 0 || head.x > worldSize || head.y < 0 || head.y > worldSize) {
                    wormsToKill.add(attacker);
                    continue;
                }
                for (const target of allWorms) {
                    if (attacker.id === target.id) continue;
                    for (let i = 1; i < target.segments.length; i++) {
                        const segment = target.segments[i];
                        const dx = head.x - segment.x;
                        const dy = head.y - segment.y;
                        if (dx*dx + dy*dy < attacker.radius * attacker.radius) {
                            wormsToKill.add(attacker);
                            break;
                        }
                    }
                    if (wormsToKill.has(attacker)) break;
                }
            }

            wormsToKill.forEach(worm => killWorm(worm));
            
            if (gameState === 'playing') {
                scoreEl.textContent = player.segments.length;
            }
        }
        
        function killWorm(worm) {
            if (worm.isPlayer) {
                if (gameState === 'playing') endGame();
            } else {
                const index = aiWorms.findIndex(w => w.id === worm.id);
                if (index > -1) {
                    const foodCount = Math.min(worm.segments.length, 50);
                    for (let i = 0; i < foodCount; i++) {
                        const seg = worm.segments[Math.floor(Math.random() * worm.segments.length)];
                        const food = new Food(seg.x, seg.y, true);
                        food.color = worm.color;
                        foods.push(food);
                    }
                    aiWorms.splice(index, 1);
                    setTimeout(() => aiWorms.push(new Worm()), 2000);
                }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if(player && camera) {
                camera.x += (player.segments[0].x - canvas.width / 2 - camera.x) * 0.1;
                camera.y += (player.segments[0].y - canvas.height / 2 - camera.y) * 0.1;
            }

            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            // Draw grid
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 1;
            const step = 50;
            const startX = Math.floor(camera.x / step) * step;
            const startY = Math.floor(camera.y / step) * step;
            for (let x = startX; x < startX + canvas.width + step; x += step) { ctx.beginPath(); ctx.moveTo(x, startY); ctx.lineTo(x, startY + canvas.height + step); ctx.stroke(); }
            for (let y = startY; y < startY + canvas.height + step; y += step) { ctx.beginPath(); ctx.moveTo(startX, y); ctx.lineTo(startX + canvas.width + step, y); ctx.stroke(); }
            
            // Draw world bounds
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.lineWidth = 20;
            ctx.strokeRect(-10, -10, worldSize + 20, worldSize + 20);
            ctx.lineWidth = 1;

            foods.forEach(f => f.draw());
            ctx.shadowBlur = 0;
            aiWorms.forEach(w => w.draw());
            if(player) player.draw();

            ctx.restore();

            // Draw joystick on top of everything
            if (joystickActive) {
                ctx.beginPath();
                ctx.arc(joystickCenter.x, joystickCenter.y, 60, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.fill();

                ctx.beginPath();
                ctx.arc(joystickCenter.x + joystickVector.x, joystickCenter.y + joystickVector.y, 35, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.fill();
            }
        }

        function gameLoop() {
            if (gameState === 'playing') {
                update();
            }
            draw();
            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            const startPlaying = () => {
                resetGame();
                if (!sfx) initAudio();
                if (Tone.Transport.state !== 'started') Tone.Transport.start();
                gameState = 'playing';
                startScreen.style.display = 'none';
                gameOverScreen.style.display = 'none';
                scoreBoard.style.display = 'block';
            };

            // Memulai audio context jika belum berjalan (penting untuk mobile)
            if (Tone.context.state !== 'running') {
                Tone.start().then(startPlaying);
            } else {
                startPlaying();
            }
        }

        function endGame() {
            if (gameState !== 'playing') return;
            if (sfx && sfx.gameOver) sfx.gameOver.triggerAttackRelease("C3", "2n");
            if (Tone.Transport.state === 'started') Tone.Transport.stop();
            gameState = 'gameOver';
            finalScoreEl.textContent = player.segments.length;
            gameOverScreen.style.display = 'flex';
            scoreBoard.style.display = 'none';
            joystickActive = false; // [FIX] Pastikan joystick nonaktif saat game over
        }
        
        function initAudio() {
            if (sfx) return;
            sfx = {
                eat: new Tone.Synth({oscillator: {type: 'triangle'}, envelope: {attack: 0.005, decay: 0.1, sustain: 0.1, release: 0.2}}).toDestination(),
                gameOver: new Tone.Synth().toDestination()
            };
            music = new Tone.FMSynth({
                harmonicity: 1.5, modulationIndex: 1.2,
                envelope: { attack: 2, decay: 1, sustain: 0.5, release: 4 },
            }).toDestination();
            music.volume.value = -20;
            const musicLoop = new Tone.Loop(time => {
                music.triggerAttackRelease("C2", "1n", time);
            }, "1n").start(0);
        }

        // --- EVENT LISTENERS ---
        // [FIX] Menambahkan event listener untuk tombol Start dan Restart
        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', startGame);

        // Desktop
        window.addEventListener('mousemove', (e) => {
            if (isTouchDevice) return; // Abaikan mouse jika ini perangkat sentuh
            mousePos = { x: e.clientX, y: e.clientY };
        });
        window.addEventListener('mousedown', () => { if(gameState === 'playing' && !isTouchDevice) isBoosting = true; });
        window.addEventListener('mouseup', () => { if(gameState === 'playing' && !isTouchDevice) isBoosting = false; });
        
        // Mobile Touch Controls
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameState === 'playing') {
                joystickActive = true;
                joystickCenter = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                isBoosting = true; // Di mobile, bergerak = boost
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (gameState === 'playing' && joystickActive) {
                const currentPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                let dx = currentPos.x - joystickCenter.x;
                let dy = currentPos.y - joystickCenter.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const maxDist = 60; // Batas pergerakan knob joystick
                if (dist > maxDist) {
                    dx = (dx / dist) * maxDist;
                    dy = (dy / dist) * maxDist;
                }
                joystickVector = { x: dx, y: dy };
            }
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (gameState === 'playing') {
                joystickActive = false;
                isBoosting = false;
                joystickVector = { x: 0, y: 0 }; // Reset vector
            }
        });

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
        
        // --- Initial Call ---
        resetGame();
        gameLoop();

    </script>
</body>
</html>
