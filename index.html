<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Arena Cacing Kosmik (Gameplay Fixed)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        body { margin: 0; background-color: #000; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; font-family: 'Arial', sans-serif; -webkit-user-select: none; user-select: none; }
        canvas { display: block; background-color: #0d1117; }
        .ui-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; flex-direction: column; background-color: rgba(0,0,0,0.8); color: white; text-align: center; z-index: 10; padding: 20px; box-sizing: border-box; }
        h1 { font-size: 2.5rem; text-shadow: 0 0 10px #00ffff; }
        p { font-size: 1.1rem; line-height: 1.5; }
        button { padding: 1rem 2rem; font-size: 1.5rem; background-color: #00aaff; color: white; border: 2px solid #00ffff; border-radius: 10px; cursor: pointer; transition: all 0.2s; }
        button:hover, button:active { background-color: #00ffff; color: #000; }
        #score-board { position: absolute; top: 20px; left: 20px; color: white; font-size: 1.5em; text-shadow: 0 0 5px #fff; display: none; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="score-board">Panjang: <span id="score">0</span></div>
    <div id="start-screen" class="ui-overlay">
        <h1>Arena Cacing Kosmik</h1>
        <p id="instruction-text"><b>Gerakkan mouse</b> untuk mengarahkan cacing.<br><b>Tahan klik</b> untuk nge-boost!</p>
        <p>Cacing akan terus bergerak. Jangan menabrak musuh atau dinding!</p>
        <button id="start-button">Mulai</button>
    </div>
    <div id="game-over-screen" class="ui-overlay" style="display: none;">
        <h1>GAME OVER</h1>
        <p>Panjang Akhir: <span id="final-score">0</span></p>
        <button id="restart-button">Coba Lagi</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // UI Elements
        const scoreEl = document.getElementById('score');
        const scoreBoard = document.getElementById('score-board');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreEl = document.getElementById('final-score');
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');
        const instructionText = document.getElementById('instruction-text');

        // Game State
        let player, foods, aiWorms, camera, sfx, music;
        let gameState = 'start';
        const worldSize = 3000;
        let isBoosting = false;

        const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        if (isTouchDevice) {
            instructionText.innerHTML = "<b>Sentuh dan geser</b> di layar untuk mengarahkan cacing.<br>Cacing akan nge-boost otomatis saat disentuh.";
        }

        class Worm {
            constructor(isPlayer = false) {
                this.isPlayer = isPlayer;
                this.id = Math.random();
                this.x = Math.random() * worldSize;
                this.y = Math.random() * worldSize;
                this.radius = 10;
                this.baseSpeed = isPlayer ? 3 : 1.8;
                this.speed = this.baseSpeed;
                this.color = `hsl(${Math.random() * 360}, 100%, 50%)`;
                this.segments = [];
                for (let i = 0; i < 15; i++) {
                    this.segments.push({ x: this.x, y: this.y });
                }
                // [FIX-GLITCH-2] Cacing kini punya properti angle, bukan target x,y
                this.angle = Math.random() * Math.PI * 2;
                this.targetFood = null; // Untuk AI
            }

            update() {
                // [FIX-GLITCH-1] Logika boost disederhanakan
                if (this.isPlayer && isBoosting && this.segments.length > 15) {
                    this.speed = this.baseSpeed * 2;
                    if (Math.random() > 0.8) {
                        const tail = this.segments.pop();
                        const droppedFood = new Food(tail.x, tail.y, true);
                        droppedFood.color = this.color;
                        foods.push(droppedFood);
                    }
                } else {
                    this.speed = this.baseSpeed;
                }
                
                // [FIX-GLITCH-3] Logika AI untuk mencari makanan
                if (!this.isPlayer) {
                    // Cari makanan terdekat sebagai target, tapi tidak setiap frame agar hemat performa
                    if (!this.targetFood || this.targetFood.eaten || Math.random() < 0.05) {
                        let closestFood = null;
                        let minDistanceSq = Infinity;
                        for (const food of foods) {
                            if(food.eaten) continue;
                            const dx = food.x - this.segments[0].x;
                            const dy = food.y - this.segments[0].y;
                            const distSq = dx * dx + dy * dy;
                            if (distSq < minDistanceSq) {
                                minDistanceSq = distSq;
                                closestFood = food;
                            }
                        }
                        this.targetFood = closestFood;
                    }
                    // Arahkan ke makanan target
                    if (this.targetFood) {
                        const dx = this.targetFood.x - this.segments[0].x;
                        const dy = this.targetFood.y - this.segments[0].y;
                        // Belokkan sudut secara perlahan, jangan instan
                        const targetAngle = Math.atan2(dy, dx);
                        let angleDiff = targetAngle - this.angle;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        this.angle += angleDiff * 0.1; // Kecepatan belok
                    }
                }
                
                // [FIX-GLITCH-2] Cacing selalu bergerak maju berdasarkan sudutnya
                const vx = Math.cos(this.angle) * this.speed;
                const vy = Math.sin(this.angle) * this.speed;
                this.segments[0].x += vx;
                this.segments[0].y += vy;
                
                // Update sisa tubuh cacing
                for (let i = 1; i < this.segments.length; i++) {
                    const dx_s = this.segments[i-1].x - this.segments[i].x;
                    const dy_s = this.segments[i-1].y - this.segments[i].y;
                    const dist_s = Math.sqrt(dx_s * dx_s + dy_s * dy_s);
                    const lag = this.radius * 0.5; // Jarak antar segmen
                    if (dist_s > lag) {
                        this.segments[i].x = this.segments[i-1].x - dx_s / dist_s * lag;
                        this.segments[i].y = this.segments[i-1].y - dy_s / dist_s * lag;
                    }
                }
            }

            draw() { /* ... fungsi draw tidak perlu diubah ... */ }
            grow() { /* ... fungsi grow tidak perlu diubah ... */ }
        }

        class Food {
            constructor(x, y, isDeathPellet = false) {
                this.x = x || Math.random() * worldSize;
                this.y = y || Math.random() * worldSize;
                this.radius = isDeathPellet ? 7 : 5;
                this.isDeathPellet = isDeathPellet;
                this.color = `hsl(${Math.random() * 360}, 100%, 75%)`;
                this.eaten = false; // Properti untuk menandai makanan yg sudah ditarget AI
            }
            draw() { /* ... fungsi draw tidak perlu diubah ... */ }
        }

        // --- GAME LOGIC FUNCTIONS (update, killWorm, etc) ---
        function resetGame() { /* ... */ }

        function update() {
            if (gameState !== 'playing') return;
            const allWorms = [player, ...aiWorms];
            allWorms.forEach(w => w.update());

            allWorms.forEach(worm => {
                for (let i = foods.length - 1; i >= 0; i--) {
                    const food = foods[i];
                    if (food.eaten) continue;
                    const dx = worm.segments[0].x - food.x;
                    const dy = worm.segments[0].y - food.y;
                    if (dx*dx + dy*dy < (worm.radius + food.radius)**2) {
                        if (worm.isPlayer && sfx) sfx.eat.triggerAttackRelease("C5", "8n");
                        
                        food.eaten = true; // Tandai sudah dimakan
                        foods.splice(i, 1);
                        
                        if (!food.isDeathPellet) {
                            foods.push(new Food());
                        }
                        worm.grow(); // Fungsi grow sekarang akan lebih sering terpanggil
                        break; 
                    }
                }
            });
            // ... sisa fungsi update (collision detection) tidak banyak berubah
        }

        // ... Sisa fungsi (killWorm, draw, gameLoop, startGame, endGame, initAudio)
        // Sebagian besar tidak memerlukan perubahan signifikan selain listener

        // --- EVENT LISTENERS ---
        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', startGame);

        // [FIX-GLITCH-2] Kontrol diubah untuk mengatur sudut, bukan target
        window.addEventListener('mousemove', (e) => {
            if (isTouchDevice || gameState !== 'playing' || !player) return;
            const canvasCenterX = canvas.width / 2;
            const canvasCenterY = canvas.height / 2;
            player.angle = Math.atan2(e.clientY - canvasCenterY, e.clientX - canvasCenterX);
        });
        window.addEventListener('mousedown', () => { if(gameState === 'playing' && !isTouchDevice) isBoosting = true; });
        window.addEventListener('mouseup', () => { if(gameState === 'playing' && !isTouchDevice) isBoosting = false; });
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameState === 'playing') {
                isBoosting = true; // Di mobile, sentuh = boost
                updateTouchAngle(e.touches[0]);
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (gameState === 'playing') {
                updateTouchAngle(e.touches[0]);
            }
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            if (gameState === 'playing') isBoosting = false;
        });
        
        function updateTouchAngle(touchEvent) {
            if (!player) return;
            const canvasCenterX = canvas.width / 2;
            const canvasCenterY = canvas.height / 2;
            player.angle = Math.atan2(touchEvent.clientY - canvasCenterY, touchEvent.clientX - canvasCenterX);
        }

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
        
        resetGame();
        gameLoop();
        
        // Salin fungsi-fungsi yang tidak berubah dari kode lama Anda ke sini
        // seperti draw(), grow(), killWorm(), resetGame(), dll.
        // Saya telah menyertakan kerangkanya, tetapi untuk singkatnya
        // Anda bisa copy-paste fungsi lengkap dari kode sebelumnya.
    </script>
</body>
</html>
